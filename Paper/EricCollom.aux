\relax 
\citation{FINCH2:2009}
\citation{Assembly:2010}
\citation{FINCH:2011}
\citation{Assembly:2010}
\citation{FINCH:2011}
\citation{Assembly:2010}
\citation{FINCH:2011}
\citation{FINCH:2011}
\citation{Assembly:2010}
\@writefile{toc}{\contentsline {section}{\numberline {1}Introduction}{\thepage }}
\@writefile{toc}{\contentsline {section}{\numberline {2}Background}{\thepage }}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.1}Evolutionary Computation}{\thepage }}
\citation{JavaBytecode:2014}
\citation{x86tomachine:2013}
\citation{x86assembly:2014}
\citation{FINCH2:2009}
\citation{JVMspec:2013}
\citation{JVMspec:2013}
\citation{Oracle:2013}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces The process of of Evolutionary Computation}}{\thepage }}
\newlabel{ECdiagram}{{1}{\thepage }}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2}x86 Assembly \& Java Bytecode}{\thepage }}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.2.1}X86}{\thepage }}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces In this example we are assuming that the frame already contains the local variables 1 and 3 to retain simplicity. This Java bytecode sequence pushes two numbers to the stack and adds them and returns the value.}}{\thepage }}
\newlabel{stack}{{2}{\thepage }}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.2.2} Bytecode and the JVM}{\thepage }}
\citation{FINCH:2011}
\citation{Oracle:2013}
\citation{Assembly:2010}
\citation{FINCH:2011}
\citation{Assembly:2010}
\citation{FINCH2:2009}
\citation{FINCH2:2009}
\citation{Assembly:2010}
\citation{FINCH:2011}
\citation{Assembly:2010}
\citation{Assembly:2010}
\citation{Forrest:2009}
\citation{FINCH2:2009}
\citation{FINCH:2011}
\citation{FINCH2:2009}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces Both (a) and (b) are valid code syntactically however only (a) is valid semantically.}}{\thepage }}
\newlabel{semantics}{{3}{\thepage }}
\@writefile{toc}{\contentsline {section}{\numberline {3}Instruction-level Code Benefits}{\thepage }}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.1}Source Code Constraints}{\thepage }}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.2}Flexibility for Individuals}{\thepage }}
\@writefile{toc}{\contentsline {section}{\numberline {4}FINCH}{\thepage }}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.1}Selecting Offspring}{\thepage }}
\citation{FINCH2:2009}
\citation{FINCH:2011}
\citation{Assembly:2010}
\citation{Assembly:2010}
\citation{Assembly:2010}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces This is an example of two possible outcomes of performing unrestricted crossover on parent 1 and 2.}}{\thepage }}
\newlabel{crossover}{{4}{\thepage }}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.2}Crossover}{\thepage }}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.3}Non-Halting Offspring}{\thepage }}
\@writefile{toc}{\contentsline {section}{\numberline {5}Automated Bug Repair}{\thepage }}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.1}Selecting Offspring }{\thepage }}
\citation{Assembly:2010}
\citation{Assembly:2010}
\citation{FINCH:2011}
\citation{Assembly:2010}
\citation{FINCH:2011}
\citation{Assembly:2010}
\citation{FINCH:2011}
\citation{Assembly:2010}
\citation{Assembly:2010}
\citation{FINCH:2011}
\citation{FINCH:2011}
\citation{koza:1992}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.2}Genetic Operators}{\thepage }}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.3}Non-Halting Offspring}{\thepage }}
\@writefile{toc}{\contentsline {section}{\numberline {6}Results}{\thepage }}
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces Example of a possible starting program to evolve and solve symbolic regression.}}{\thepage }}
\newlabel{regression}{{5}{\thepage }}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.1}FINCH}{\thepage }}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.1.1}Symbolic Regression}{\thepage }}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.1.2}Array Sum}{\thepage }}
\citation{Assembly:2010}
\citation{Forrest:2009}
\citation{Forrest:2009}
\citation{FINCH:2011}
\citation{Assembly:2010 FINCH:2011}
\bibstyle{abbrv}
\bibdata{EricBibliography}
\bibcite{Oracle:2013}{1}
\bibcite{JVMspec:2013}{2}
\bibcite{Forrest:2009}{3}
\bibcite{koza:1992}{4}
\bibcite{FINCH2:2009}{5}
\bibcite{FINCH:2011}{6}
\bibcite{Assembly:2010}{7}
\bibcite{x86tomachine:2013}{8}
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces Initial population function, for array sum, that enters into infinite recursion in the if statement}}{\thepage }}
\newlabel{initial rec}{{6}{\thepage }}
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces FINCH's solution to the intial program presented in Figure\nobreakspace  {}6\hbox {}}}{\thepage }}
\newlabel{final rec}{{7}{\thepage }}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.2}Automated Bug Repair}{\thepage }}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.3}Future Work}{\thepage }}
\@writefile{toc}{\contentsline {section}{\numberline {7}Conclusion}{\thepage }}
\@writefile{toc}{\contentsline {section}{\numberline {8}Acknowledgments}{\thepage }}
\@writefile{toc}{\contentsline {section}{\numberline {9}References}{\thepage }}
\bibcite{JavaBytecode:2014}{9}
\bibcite{x86assembly:2014}{10}
