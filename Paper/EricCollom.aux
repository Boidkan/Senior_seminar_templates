\relax 
\citation{FINCH2:2009}
\citation{Assembly:2010}
\citation{FINCH:2011}
\citation{Assembly:2010}
\citation{FINCH:2011}
\citation{Assembly:2010}
\citation{FINCH:2011}
\citation{FINCH:2011}
\citation{Assembly:2010}
\@writefile{toc}{\contentsline {section}{\numberline {1}Introduction}{\thepage }}
\@writefile{toc}{\contentsline {section}{\numberline {2}Background}{\thepage }}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.1}Evolutionary Computation}{\thepage }}
\citation{JavaBytecode:2014}
\citation{x86tomachine:2013}
\citation{x86assembly:2014}
\citation{FINCH2:2009}
\citation{FINCH:2011}
\citation{JVMspec:2013}
\citation{Oracle:2013}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces The process of of Evolutionary Computation}}{\thepage }}
\newlabel{ECdiagram}{{1}{\thepage }}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2}x86 Assembly \& Java Bytecode}{\thepage }}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces Both (a) and (b) are valid code syntactically however only (a) is valid semanticly.}}{\thepage }}
\newlabel{semantics}{{2}{\thepage }}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.2.1}X86}{\thepage }}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.2.2} Bytcode and the JVM}{\thepage }}
\@writefile{toc}{\contentsline {section}{\numberline {3}Instruction-level Code Benefits}{\thepage }}
\citation{Oracle:2013}
\citation{Assembly:2010}
\citation{FINCH:2011}
\citation{Assembly:2010}
\citation{FINCH:2011}
\citation{FINCH2:2009}
\citation{FINCH2:2009}
\citation{Assembly:2010}
\citation{FINCH:2011}
\citation{Assembly:2010}
\citation{FINCH2:2009}
\citation{FINCH:2011}
\citation{FINCH2:2009}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces Index zero of the frame is a reference to the methods current class. Istore\_n pushes an element from index n from frame onto stack. Iadd pops two elements from operand stack add them together and then pushes to the result to the stack. Ireturn pops an element from the stack and returns it}}{\thepage }}
\newlabel{stack}{{3}{\thepage }}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.1}Source Code Constraints}{\thepage }}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.2}Flexibility}{\thepage }}
\@writefile{toc}{\contentsline {section}{\numberline {4}FINCH}{\thepage }}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.1}Selecting Offspring}{\thepage }}
\citation{FINCH2:2009}
\citation{FINCH:2011}
\citation{Assembly:2010}
\citation{Assembly:2010}
\citation{FINCH:2011}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces This is an example of good and bad crossover. iconst\_n pushes onto the stack an int of value n. istore\_n pops the stack and saves the value on the frame at index n. Look at figure\nobreakspace  {}3\hbox {} for a description of iload,iadd,isub,and ireturn.}}{\thepage }}
\newlabel{crossover}{{4}{\thepage }}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.2}Crossover}{\thepage }}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.3}Non-Halting Offspring}{\thepage }}
\@writefile{toc}{\contentsline {section}{\numberline {5}Evolving Assembly Code}{\thepage }}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.1}Selecting Offspring }{\thepage }}
\citation{Assembly:2010}
\citation{FINCH:2011}
\citation{FINCH:2011}
\citation{FINCH:2011}
\citation{koza:1992}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.2}Genetic Operators}{\thepage }}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.3}Non-Halting Offspring}{\thepage }}
\@writefile{toc}{\contentsline {section}{\numberline {6}Results}{\thepage }}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.1}FINCH}{\thepage }}
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces Example of a possible starting program to evolve and solve symbolic regression.}}{\thepage }}
\newlabel{regression}{{5}{\thepage }}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.1.1}Symbolic Regression}{\thepage }}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.1.2}Array Sum}{\thepage }}
\citation{FINCH:2011}
\citation{Assembly:2010}
\bibstyle{abbrv}
\bibdata{EricBibliography}
\bibcite{Oracle:2013}{1}
\bibcite{JVMspec:2013}{2}
\bibcite{JavaBytecode:2014}{3}
\bibcite{koza:1992}{4}
\bibcite{FINCH2:2009}{5}
\bibcite{FINCH:2011}{6}
\bibcite{Assembly:2010}{7}
\bibcite{x86tomachine:2013}{8}
\bibcite{x86assembly:2014}{9}
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces Initial population function, for array sum, that enters into infinite recursion in the if statement}}{\thepage }}
\newlabel{initial rec}{{6}{\thepage }}
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces FINCH's solution to the intial program presented in Figure\nobreakspace  {}6\hbox {}}}{\thepage }}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.2}x86}{\thepage }}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.3}Future Work}{\thepage }}
\@writefile{toc}{\contentsline {section}{\numberline {7}Conclusion}{\thepage }}
\@writefile{toc}{\contentsline {section}{\numberline {8}Acknowledgments}{\thepage }}
\@writefile{toc}{\contentsline {section}{\numberline {9}References}{\thepage }}
